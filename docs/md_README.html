<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>My Project: Mathilda</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">My Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title"><a class="el" href="class_mathilda.html">Mathilda</a> </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>A C++ class for writing fast and scalable web exploits and scanners.</p>
<p>Disclaimer: I had to strip some of <a class="el" href="class_mathilda.html">Mathilda</a>'s important functionality in order to open source it. You may need to do some modifications and tweaking in order for it to be useful for you. Feel free to reach out to me with your ideas and pull requests.</p>
<h2>What</h2>
<p><a class="el" href="class_mathilda.html">Mathilda</a> is a multi-process libcurl/libuv wrapper written (mostly) in C++11. <a class="el" href="class_mathilda.html">Mathilda</a> allows you to write fast web testing tools that can operate at scale. But what does scale mean in this context? It means horizontal scaling and distribution of work across worker processes wherever possible.</p>
<p>Using these classes you can write tools that work quickly against a very large set of hosts. Some good examples are command injection crawlers, XXE exploits, SSRF, or HTTP header discovery tools.</p>
<p><a class="el" href="class_mathilda.html">Mathilda</a> is not a singleton, you can have multiple <a class="el" href="class_mathilda.html">Mathilda</a> class instances in your program. Each class instance manages its own internal state with regards to child processes, libuv, and libcurl. The point is to abstract a lot of that away but still give you access to the bits that you want to customize.</p>
<h2>Why</h2>
<p>The libcurl API is good, but I needed something that wrapped all the plumbing code you normally rewrite with each new command line web testing tool. <a class="el" href="class_mathilda.html">Mathilda</a> is a library that handles all of that for you. All you have to do is focus on writing the code that defines the requests and does something with the responses. All of this will be automatically distributed for you across a pool of worker processes that invoke your callbacks. I have benchmarked it doing simple tasks at around ~10,000 HTTP GET requests per second on a 24 core system.</p>
<h2>How</h2>
<p><a class="el" href="class_mathilda.html">Mathilda</a> takes a list of <a class="el" href="class_instruction.html">Instruction</a> class instances. Each <a class="el" href="class_instruction.html">Instruction</a> class represents a specific HTTP request to be made. These <a class="el" href="class_instruction.html">Instruction</a> class instances tell <a class="el" href="class_mathilda.html">Mathilda</a> how to make a request and defines pre and post function callback pointers to handle the request and response appropriately.</p>
<p>Depending on the number of cores your system has <a class="el" href="class_mathilda.html">Mathilda</a> manages a pool of worker processes for efficiently distributing work with an event model implemented by libuv. This design was chosen to minimize the impact that slower servers have on performance. More on that below.</p>
<p>It is important to note that <a class="el" href="class_mathilda.html">Mathilda</a> calls fork to create the child processes. This is normally a bad choice for library designs but suits our needs perfectly. <a class="el" href="class_mathilda.html">Mathilda</a> manages these child processes with a class named <a class="el" href="class_mathilda_fork.html">MathildaFork</a>. You can use this class directly from your own code to manage child processes if you want but its purely optional.</p>
<p>A bit of history for you. This code was originally a threadpool but I ran into limitations with using evented IO from threads because nothing is thread safe. You end up having to message a worker thread to safely update timers to avoid race conditions and dead locks. Which quickly becomes very inefficient and complex code. This is true of libuv, libevent, and libev in one form or another. The complexity began to outweigh the performance hit of forking. If you don't care about using and evented IO with libcurl then you can safely use a threadpool and its fast-enough. However you will need to use select with libcurls multi interface, which is older and slower than epoll, which libuv manages for us. In fact theres probably more asynchronous operations we could be using libuv for but aren't yet. If you're interested in how some of the <a class="el" href="class_mathilda.html">Mathilda</a> bits are reusable see Mathilda::name_to_addr_a and how it uses <a class="el" href="class_mathilda_fork.html">MathildaFork</a> to distribute DNS lookups across worker processes.</p>
<h2>API</h2>
<p>All source code is documented using Doxygen and the documentation automatically created in the project. Everything below is a quick start guide to familiarize you with how to use <a class="el" href="class_mathilda.html">Mathilda</a> and <a class="el" href="class_instruction.html">Instruction</a> classes. I recommend starting here and referring to the Doxygen generated documentation when writing code.</p>
<h3><a class="el" href="class_mathilda.html">Mathilda</a> class functions</h3>
<ul>
<li>add_instruction(Instruction *) - Adds an <a class="el" href="class_instruction.html">Instruction</a> class to an internally managed vector</li>
<li>execute_instructions() - Instructs <a class="el" href="class_mathilda.html">Mathilda</a> to start scanning hosts</li>
<li>clear_instructions() - Clears the instructions vector <a class="el" href="class_mathilda.html">Mathilda</a> holds, rarely used</li>
</ul>
<h3><a class="el" href="class_mathilda.html">Mathilda</a> class members</h3>
<ul>
<li>safe_to_fork - A bool indicating whether it is OK to fork (default: true)</li>
<li>use_shm - A bool indicating whether shared memory segments should be allocated (default: false)</li>
<li>set_cpu - A bool that tells <a class="el" href="class_mathilda.html">Mathilda</a> to try and bind to a specific CPU with sched_setaffinity (default: true)</li>
<li>timeout_seconds - The number of seconds a child process should be given before a SIGALRM is sent</li>
<li>finish(uint8_t *) - Callback function pointer, executed after child exits. Passed a pointer to shared memory</li>
</ul>
<h3><a class="el" href="class_mathilda.html">Mathilda</a> class misc</h3>
<ul>
<li>MATHILDA_FORK - Environment variable that when set tells <a class="el" href="class_mathilda.html">Mathilda</a> it is OK to fork</li>
</ul>
<h3><a class="el" href="class_instruction.html">Instruction</a> class members</h3>
<p>This class needs to be created with the new operator, filled in, and passed to the Mathilda::add_instruction function</p><ul>
<li>host (std::string) - The hostname to scan</li>
<li>path (std::string) - The URI to request</li>
<li>http_method (std::string) - The HTTP method to use (GET/POST)</li>
<li>post_body (std::string) - The POST body to send to the server</li>
<li>cookie_file (std::string) - Location on disk of a Curl cookie file</li>
<li>user_agent (std::string) - User agent string to use (default is Chrome)</li>
<li>proxy (std::string) - Hostname of the proxy you want to use</li>
<li>port (short) - Server port to connect to</li>
<li>proxy_port (short) - Proxy port to connect to</li>
<li>response_code (int) - Invoke the after callback only if HTTP response matches this (0 for always invoke)</li>
<li>ssl (boolean) - SSL support</li>
<li>include_headers (bool) - Include HTTP headers with the after callback (Response-&gt;text will include them)</li>
<li>use_proxy (boolean) - Use the proxy configured with proxy/proxy_port</li>
<li>follow_redirects (boolean) - Follow HTTP redirects</li>
<li>curl_code (CURLCode) - The Curl response code returned after the request is finished</li>
<li>before(Instruction *, CURL *) - A callback function pointer, executed before curl_perform</li>
<li>after(Instruction *, CURL *, Response *) - Callback function pointer, executed after curl_perform</li>
</ul>
<h3><a class="el" href="class_mathilda_utils.html">MathildaUtils</a> static class functions</h3>
<p>These utility functions were written to make writing libmathilda tools easier. When working with HTTP and URIs you often need to work a collection of strings in some way. Sometimes its tokenizing them, or modifying them for fuzzing. These functions will help you do those kinds of operations using simple STL containers. The documentation for each function is auto generated using doxygen. Please see the 'docs' directory for more information.</p><ul>
<li>name_to_addr(std::string const &amp;, std::vector&lt;std::string&gt; &amp;, bool) - Synchronous DNS lookups</li>
<li>name_to_addr_a(std::vector&lt;std::string&gt; const &amp;, std::vector&lt;std::string&gt; &amp;) - Asynchronous DNS lookups</li>
<li>shm_store_string(uint8_t *, const char *, size_t) - Stores a string in shared memory in [length,string] format</li>
<li>get_http_headers(const char *, std::map&lt;std::string, std::string&gt; &amp;) - Returns a std::map of HTTP headers from a raw HTTP response</li>
<li>read_file(char *, std::vector&lt;std::string&gt; &amp;) - Reads a file line by line into a std::vector</li>
<li>unique_string_vector(vector&lt;std::string&gt; &amp;) - Removes duplicate entries from a std::vector of std::string</li>
<li>split(const std::string &amp;, char, std::vector&lt;std::string&gt; &amp;) - Splits a std::string according to a delimeter</li>
<li>replaceAll(std::string &amp;, const std::string &amp;, const std::string &amp;) - Replaces all occurences of X within a std::string with Y</li>
<li>link_blacklist(std::string const &amp;) - Checks a std::string against a blacklist of URI's</li>
<li>page_blacklist(std::string const &amp;) - Checks a std::string against a blacklist of content</li>
<li>is_http_uri(std::string const &amp;) - Returns true if a URI is an HTTP URI</li>
<li>is_https_uri(std::string const &amp;) - Returns true if a URI is an HTTPS URI</li>
<li>is_subdomain(std::string const &amp;) - Returns true if a URI is a subdomain</li>
<li>is_domain_host(std::string const &amp;, std::string const &amp;) - Returns true if a URI matches a domain</li>
<li>extract_host_from_uri(std::string const &amp;) - Extracts the hostname from a URI</li>
<li>extract_path_from_uri(std::string const &amp;) - Extracts the path from a URI</li>
<li>normalize_uri(std::string const &amp;) - Attempts to normalize a URI</li>
</ul>
<h3><a class="el" href="struct_response.html">Response</a> Structure</h3>
<p>This structure tracks the raw response from a web server. A pointer to the <a class="el" href="struct_response.html">Response</a> structure is passed to the <a class="el" href="class_mathilda.html">Mathilda</a> 'after' callback. Its members are:</p><ul>
<li>text - A char pointer to whatever the server responded with</li>
<li>size - The size of the data the server responded with</li>
</ul>
<h3><a class="el" href="struct_wait_result.html">WaitResult</a> Structure</h3>
<p>This structure is used by MathildaUtils::wait to return information about a child process to a caller. This function implements a basic wait loop for all child processes. A pointer to an instance of this structure is passed to the function and is filled out upon it returning. Its members are:</p><ul>
<li>return_code - An int representing the return code of an exited child</li>
<li>int signal - An int representing the signal received by the child</li>
<li>pid - The pid returned by waitpid</li>
</ul>
<h3><a class="el" href="struct_process_info.html">ProcessInfo</a> Structure</h3>
<p>This structure is used by <a class="el" href="class_mathilda_fork.html">MathildaFork</a> to track child processes. An instance of this structure exists for each child process the class is currently managing. A single instance of this structure also exists in the <a class="el" href="class_mathilda_fork.html">MathildaFork</a> class instance itself but is only intended to be accessed by child processes. Its members are:</p><ul>
<li>pid - The PID of the child process</li>
<li>shm_id - Shared memory key/id</li>
<li>shm_size - Size of the shared memory segment</li>
<li>shm_ptr - Raw pointer to the shared memory segment</li>
</ul>
<h2>Writing <a class="el" href="class_mathilda.html">Mathilda</a> callbacks</h2>
<p>Writing <a class="el" href="class_mathilda.html">Mathilda</a> callbacks is painless as long as you make use of C++11 std::function or lambdas. Heres an example in pseudocode:</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;void my_after(Instruction *i, CURL *c, Response *r) {</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;    printf(&quot;Response from %s:\n%s\n&quot;, i-&gt;host.c_str(), r-&gt;text);</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;    return;</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;}</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;...</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;Mathilda *m = new Mathilda();</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;Instruction *i = new Instruction((char *) &quot;example.test.example.com&quot;, (char *) &quot;/test.html&quot;);</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;i-&gt;after = my_after;    // i-&gt;after is a std::function</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;m-&gt;add_instruction(i);</div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;m-&gt;execute_instructions();</div></div><!-- fragment --><p>This tells <a class="el" href="class_mathilda.html">Mathilda</a> to invoke the my_after function after a request has been made. You can access the <a class="el" href="class_instruction.html">Instruction</a>, Curl, and <a class="el" href="struct_response.html">Response</a> members passed to the callback like any other. Please see the API documentation above for the details on what they expose.</p>
<p>The Instruction::before callback executes before the Curl Easy handle is passed to Curl, giving you an opportunity to override any of the settings <a class="el" href="class_mathilda.html">Mathilda</a> has set on the handle.</p>
<p>The Instruction::after callback executes once the Curl call is completed and gives you the opportunity to inspect the response headers or content. This is only invoked if the HTTP response code matches Instruction::response_code or if Instruction::response_code is set to 0.</p>
<p>The Mathilda::finish callback executes after a child process has exited and gives you the opportunity to use the shared memory segment before it is destroyed. In most cases you want to share some results across parent and child process and these are often just strings. You can use <a class="el" href="class_mathilda_utils.html#a933f56f387781573fca2271b5a4dd1f4">MathildaUtils::shm_store_string</a> to make this easier. See the section 'Using Shared Memory' below for more information.</p>
<p>Note: If you choose not to fork (i.e. set Mathilda::safe_to_fork to false) and your connection hangs forever then you need to implement the logic to catch and recover from that. All of the neccessary libuv and libcurl handles are available for doing this. The preferred method however is to fork and set a timeout.</p>
<h3>Accessing Curl Internals</h3>
<p>Inside of every <a class="el" href="class_instruction.html">Instruction</a> object is a pointer to a <a href="http://curl.haxx.se/libcurl/c/libcurl-easy.html">Curl Easy object</a>. You can access this handle inside of your callback and make libcurl API calls to retrieve HTTP headers, status code, and anything else the libcurl API supports.</p>
<h3>Using Shared Memory</h3>
<p>The Shared Memory segment is perhaps the most complex part of <a class="el" href="class_mathilda.html">Mathilda</a>. It is %100 optional, but can be helpful when collecting results across multiple processes that would otherwise be lost. Before fork is called, each <a class="el" href="class_mathilda.html">Mathilda</a> shm_id and shm_ptr member variable is updated to point to a shared memory segment created just for that child process. In order to use this functionality the use_shm flag must be set to true when you create your <a class="el" href="class_mathilda.html">Mathilda</a> class instance. By default you get 4MB of shared memory allocated for each child process.</p>
<p>You can use this shared memory to store anything, and then access it later using the finish callback which is invoked after all child processes have exited.</p>
<h2>FAQ:</h2>
<p>Q: What third party requirements are there?</p>
<p>A: libcurl, libuv, libstdc++.x86_64 libstdc++-devel.x86_64, a modern GCC/Clang (I recommend libgumbo for HTML parsing). If you compile these from source you will likely need to set your LD_LIBRARY_PATH environment variable. You can do this with the following command:</p>
<p>export LD_LIBRARY_PATH=/usr/local/lib</p>
<p>Q: Why not just write a better libcurl?</p>
<p>A: Because theres nothing wrong with libcurl. In fact it works perfectly for both HTTP and webapp testing. But you end up writing the same code over and over everytime you want to write a small testing tool. <a class="el" href="class_mathilda.html">Mathilda</a> solves that problem by implementing the plumbing in such a way that scales your small tools up with little to no additional work.</p>
<p>Q: What has <a class="el" href="class_mathilda.html">Mathilda</a> been used for?</p>
<p>A: Web application security testing, web server and caching proxy load testing, HTTP fuzzing, and many other things.</p>
<p>Q: How do I compile/use <a class="el" href="class_mathilda.html">Mathilda</a> and these tools?</p>
<p>A: Heres the short answer:</p>
<p>Compile <a class="el" href="class_mathilda.html">Mathilda</a> as a library:</p>
<p>g++ -o libmathilda.so mathilda.cpp -lcurl -std=c++11 -shared -fPIC -rdynamic -ggdb -luv</p>
<p>Compile <a class="el" href="class_mathilda.html">Mathilda</a> unit tests (found at the bottom of Mathilda.cpp)</p>
<p>g++ -o mathilda_test mathilda.cpp -lcurl -std=c++11 -ggdb -luv -DMATHILDA_TESTING</p>
<p>You can delete the unit tests at the bottom of mathilda.cpp and replace it with your own code and use the command above.</p>
<p>Q: I specified port 443 but my program keeps trying plain text HTTP over port 443...</p>
<p>A: You probably set Instruction::port as 443 but you probably didn't set Instruction::ssl to true. Try something like this:</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;if(i-&gt;port == 443) {</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;    i-&gt;ssl = true;</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;}</div></div><!-- fragment --><h2>Who</h2>
<p><a class="el" href="class_mathilda.html">Mathilda</a> was written in 2015/2016 by Chris Rohlf at Yahoo</p>
<h2>Copyright</h2>
<p>Copyright 2015 Yahoo Inc. Licensed under the BSD license, see LICENSE file for terms. Written by Chris Rohlf </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
